\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}genericLinkedList.h\PYGZdq{}}

\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{listElementStruct}\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{printFunction}\PYG{p}{)(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{);}
\PYG{+w}{    }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{listElementStruct}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{listElement}\PYG{p}{;}

\PYG{c+c1}{//Creates a new linked list element with given content of size}
\PYG{c+c1}{//Returns a pointer to the element}
\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{createEl}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{printFunction}\PYG{p}{)(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{))}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{e}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{malloc}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{listElement}\PYG{p}{));}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{e}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{//malloc has had an error}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//return NULL to indicate an error.}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{dataPointer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{malloc}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{o}{*}\PYG{n}{size}\PYG{p}{);}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{dataPointer}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{//malloc has had an error}
\PYG{+w}{        }\PYG{n}{free}\PYG{p}{(}\PYG{n}{e}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{//release the previously allocated memory}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//return NULL to indicate an error.}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{dataPointer}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{e}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{data}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dataPointer}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{e}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{printFunction}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{printFunction}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{e}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{size}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{e}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Prints out each element in the list}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{traverse}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{)\PYGZob{}}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{p}{(}\PYG{n}{current}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)\PYGZob{}}
\PYG{+w}{        }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{printFunction}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{data}\PYG{p}{);}
\PYG{+w}{        }\PYG{c+c1}{// printf(\PYGZdq{}\PYGZpc{}s\PYGZbs{}n\PYGZdq{}, current\PYGZhy{}\PYGZgt{}data);}
\PYG{+w}{        }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Inserts a new element after the given el}
\PYG{c+c1}{//Returns the pointer to the new element}
\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{insertAfter}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{el}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{printFunction}\PYG{p}{)(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{))\PYGZob{}}
\PYG{+w}{  }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newEl}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{createEl}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{printFunction}\PYG{p}{);}
\PYG{+w}{  }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{el}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{newEl}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{el}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newEl}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{newEl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Delete the element after the given el}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{deleteAfter}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{after}\PYG{p}{)\PYGZob{}}
\PYG{+w}{  }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{delete}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{after}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newNext}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{delete}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{after}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newNext}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+c1}{//need to free the memory because we used malloc}
\PYG{+w}{  }\PYG{n}{free}\PYG{p}{(}\PYG{n}{delete}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{data}\PYG{p}{);}
\PYG{+w}{  }\PYG{n}{free}\PYG{p}{(}\PYG{n}{delete}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// returns the number of elements in the list}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{length}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{length}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// traversing the list and counting each element}
\PYG{+w}{    }\PYG{k}{while}\PYG{p}{(}\PYG{n}{current}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)\PYGZob{}}
\PYG{+w}{        }\PYG{n}{length}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{length}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// push a new element onto the head of a list and update the list reference using side effects}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{push}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{**}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{printFunction}\PYG{p}{)(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{))}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// create the new element}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newElement}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{createEl}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{printFunction}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// handle malloc errors}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{newElement}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Memory allocation failed.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{        }\PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// make the the new element point to the current head of the list}
\PYG{+w}{    }\PYG{n}{newElement}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{list}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// make the list reference to point to the new head element }
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newElement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{// pop an element from the head of a list and update the list reference using side effects}
\PYG{c+c1}{// assuming that the desired return value here is the popped element, as is standard for POP operations}
\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{pop}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{**}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// don\PYGZsq{}t bother if list is non existent}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}
\PYG{p}{;}\PYG{+w}{  }
\PYG{+w}{    }\PYG{c+c1}{// getting reference to the element to be popped}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{poppedElement}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{list}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// make the the second element the new head of the list \PYGZhy{}\PYGZhy{} this could be NULL, so the list would be NULL also}
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{list}\PYG{p}{)}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// detach the popped element from the list}
\PYG{+w}{    }\PYG{n}{poppedElement}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{poppedElement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{// enque a new element onto the head of the list and update the list reference using side effects}
\PYG{c+c1}{// essentially the same as push}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{enqueue}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{**}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{printFunction}\PYG{p}{)(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{))}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// create the new element}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newElement}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{createEl}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{printFunction}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// handle malloc errors}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{newElement}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Memory allocation failed.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{        }\PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// make the the new element point to the current head of the list}
\PYG{+w}{    }\PYG{n}{newElement}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{list}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// make the list reference to point to the new head element }
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newElement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }


\PYG{c+c1}{// dequeue an element from the tail of the list by removing the element from the list via side effects, and returning the removed item}
\PYG{c+c1}{// assuming that we want to return the dequeued element rather than the list itself, as enqueue returns nothing and uses side effects, so dequeue should also use side effects}
\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{dequeue}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// there are three cases that we must consider: a list with 0 elements, a list with 1 element, \PYGZam{} a list with \PYGZgt{}=2 elements}

\PYG{+w}{    }\PYG{c+c1}{// don\PYGZsq{}t bother if list is non existent}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// if there is only one element in the list, i.e. the head element is also the tail element, just returning this element}
\PYG{+w}{    }\PYG{c+c1}{// this means that the listElement pointer that was passed to this function won\PYGZsq{}t be updated}
\PYG{+w}{    }\PYG{c+c1}{// ideally, we would set it to NULL but we can\PYGZsq{}t do that since `list` is a pointer that has been passed by value, so we can\PYGZsq{}t update the pointer itself. we would need a pointer to a pointer to have been passed }
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// traversing the list to find the second\PYGZhy{}to\PYGZhy{}last element}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// get reference to the element to be dequeued}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{dequeuedElement}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// make the penultimate element the tail by removing reference to the old tail}
\PYG{+w}{    }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
