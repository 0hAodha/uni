\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8\relax}]
\PYG{c+c1}{// returns the number of elements in the list}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{length}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{length}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// traversing the list and counting each element}
\PYG{+w}{    }\PYG{k}{while}\PYG{p}{(}\PYG{n}{current}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)\PYGZob{}}
\PYG{+w}{        }\PYG{n}{length}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{length}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// push a new element onto the head of a list and update the list reference using side effects}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{push}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{**}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// create the new element}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newElement}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{createEl}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// handle malloc errors}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{newElement}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Memory allocation failed.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{        }\PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// make the the new element point to the current head of the list}
\PYG{+w}{    }\PYG{n}{newElement}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{list}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// make the list reference to point to the new head element}
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newElement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{// pop an element from the head of a list and update the list reference using side effects}
\PYG{c+c1}{// assuming that the desired return value here is the popped element, as is standard for POP operations}
\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{pop}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{**}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// don't bother if list is non existent}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}
\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// getting reference to the element to be popped}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{poppedElement}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{list}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// make the the second element the new head of the list -- this could be NULL, so the list would be NULL also}
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{list}\PYG{p}{)}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// detach the popped element from the list}
\PYG{+w}{    }\PYG{n}{poppedElement}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{poppedElement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{// enque a new element onto the head of the list and update the list reference using side effects}
\PYG{c+c1}{// essentially the same as push}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{enqueue}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{**}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// create the new element}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newElement}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{createEl}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// handle malloc errors}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{newElement}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Memory allocation failed.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{        }\PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// make the the new element point to the current head of the list}
\PYG{+w}{    }\PYG{n}{newElement}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{list}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// make the list reference to point to the new head element}
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newElement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{// dequeue an element from the tail of the list by removing the element from the list via side effects, and returning the removed item}
\PYG{c+c1}{// assuming that we want to return the dequeued element rather than the list itself, as enqueue returns nothing and uses side effects, so dequeue should also use side effects}
\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{dequeue}\PYG{p}{(}\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// there are three cases that we must consider: a list with 0 elements, a list with 1 element, & a list with >=2 elements}

\PYG{+w}{    }\PYG{c+c1}{// don't bother if list is non existent}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// if there is only one element in the list, i.e. the head element is also the tail element, just returning this element}
\PYG{+w}{    }\PYG{c+c1}{// this means that the listElement pointer that was passed to this function won't be updated}
\PYG{+w}{    }\PYG{c+c1}{// ideally, we would set it to NULL but we can't do that since `list` is a pointer that has been passed by value, so we can't update the pointer itself. we would need a pointer to a pointer to have been passed}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// traversing the list to find the second-to-last element}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{current}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// get reference to the element to be dequeued}
\PYG{+w}{    }\PYG{n}{listElement}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{dequeuedElement}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// make the penultimate element the tail by removing reference to the old tail}
\PYG{+w}{    }\PYG{n}{current}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
