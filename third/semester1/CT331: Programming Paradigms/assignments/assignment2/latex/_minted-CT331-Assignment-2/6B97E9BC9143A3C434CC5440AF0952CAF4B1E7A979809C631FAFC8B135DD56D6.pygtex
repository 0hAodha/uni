\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{\PYGZsh{}lang }\PYG{n+nn}{racket}

\PYG{c+c1}{;; function to display the contents of a binary search tree in sorted order}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{display\PYGZus{}contents}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{        }\PYG{c+c1}{;; if the binary search tree is null, print an empty string (nothing)}
\PYG{+w}{        }\PYG{p}{[}\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{display}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{p}{)]}

\PYG{+w}{        }\PYG{c+c1}{;; if the binary search tree has nodes}
\PYG{+w}{        }\PYG{p}{[}\PYG{k}{else}\PYG{+w}{ }
\PYG{+w}{            }\PYG{c+c1}{;; display the contents of the left sub\PYGZhy{}tree of the current node}
\PYG{+w}{            }\PYG{p}{(}\PYG{n}{display\PYGZus{}contents}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cadr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}

\PYG{+w}{            }\PYG{c+c1}{;; display the current node}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nb}{display}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nb}{newline}\PYG{p}{)}

\PYG{+w}{            }\PYG{c+c1}{;; display the contents of the right sub\PYGZhy{}tree of the current node}
\PYG{+w}{            }\PYG{p}{(}\PYG{n}{display\PYGZus{}contents}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{caddr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}
\PYG{+w}{        }\PYG{p}{]}
\PYG{+w}{    }\PYG{p}{)}
\PYG{p}{)}

\PYG{c+c1}{;; function to search a tree and tell whether a given item is presesnt in a given tree}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{search\PYGZus{}tree}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{        }\PYG{c+c1}{;; return false if we\PYGZsq{}ve reached the end of the tree without finding a match}
\PYG{+w}{        }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}

\PYG{+w}{        }\PYG{c+c1}{;; return true if the current node is equal to the item}
\PYG{+w}{        }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{equal?}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}t}\PYG{p}{)}

\PYG{+w}{        }\PYG{c+c1}{;; else return whether the item was found in the left sub\PYGZhy{}tree or the right sub\PYGZhy{}tree}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{else}
\PYG{+w}{            }\PYG{p}{(}\PYG{k}{or}
\PYG{+w}{                }\PYG{p}{(}\PYG{n}{search\PYGZus{}tree}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cadr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}\PYG{+w}{   }\PYG{c+c1}{;; search left sub\PYGZhy{}tree}
\PYG{+w}{                }\PYG{p}{(}\PYG{n}{search\PYGZus{}tree}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{caddr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}\PYG{+w}{  }\PYG{c+c1}{;; search right sub\PYGZhy{}tree}
\PYG{+w}{            }\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{)}
\PYG{p}{)}

\PYG{c+c1}{;; function to insert an item into a binary search tree}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}item}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{        }\PYG{c+c1}{;; if there are no nodes in the tree, create a new tree with the item as the root}
\PYG{+w}{        }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nb}{list}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{())}
\PYG{+w}{        }\PYG{p}{)}

\PYG{+w}{        }\PYG{c+c1}{;; if the item is less than the current node, insert it into the left\PYGZhy{}hand side of the tree}
\PYG{+w}{        }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}
\PYG{+w}{            }\PYG{c+c1}{;; create new bst with same root node, same right\PYGZhy{}hand side, but a left\PYGZhy{}hand side that has had the item inserted}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nb}{list}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}item}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cadr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{caddr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}
\PYG{+w}{        }\PYG{p}{)}

\PYG{+w}{        }\PYG{c+c1}{;; if the item is greater than the current node, insert it into the right\PYGZhy{}hand side of the tree}
\PYG{+w}{        }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}
\PYG{+w}{            }\PYG{c+c1}{;; create new bst with same root node, same left\PYGZhy{}hand side, but a right\PYGZhy{}hand side that has had the item inserted}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nb}{list}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cadr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}item}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{caddr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)))}
\PYG{+w}{        }\PYG{p}{)}

\PYG{+w}{        }\PYG{c+c1}{;; else the item is equal to the current node, so do nothing}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{else}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{)}
\PYG{p}{)}

\PYG{c+c1}{;; function to insert a list of items into a binary search tree}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}list}\PYG{+w}{ }\PYG{n}{lst}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n}{lst}\PYG{p}{)}
\PYG{+w}{        }\PYG{c+c1}{;; if the list is null, just return the bst with no changes}
\PYG{+w}{        }\PYG{n}{bst}

\PYG{+w}{        }\PYG{c+c1}{;; otherwise, recurse with the remainder of the list and the binary tree produced by inserting the first item of the list into bst}
\PYG{+w}{        }\PYG{p}{(}\PYG{n}{insert\PYGZus{}list}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cdr}\PYG{+w}{ }\PYG{n}{lst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{lst}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}
\PYG{+w}{    }\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{)}

\PYG{c+c1}{;; tree\PYGZhy{}sort function}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{tree\PYGZus{}sort}\PYG{+w}{ }\PYG{n}{lst}\PYG{p}{)}
\PYG{+w}{    }\PYG{c+c1}{;; inserting the list into a tree structure to sort it and then displaying the contents of that tree }
\PYG{+w}{    }\PYG{p}{(}\PYG{n}{display\PYGZus{}contents}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}list}\PYG{+w}{ }\PYG{n}{lst}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{()))}
\PYG{p}{)}

\PYG{c+c1}{;; function to insert an item into a binary search tree based off a sorting function}
\PYG{c+c1}{;; the sorting function should return accept two items and arguments, and return true if they were passed in order, and false otherwise or if they are equal}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}item\PYGZus{}custom}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{n}{bst}\PYG{+w}{ }\PYG{n}{sorter}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{        }\PYG{c+c1}{;; if there are no nodes in the tree, create a new tree with the item as the root}
\PYG{+w}{        }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nb}{list}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{())}
\PYG{+w}{        }\PYG{p}{)}

\PYG{+w}{        }\PYG{c+c1}{;; if the item is goes before the current node, insert it into the left\PYGZhy{}hand side of the tree}
\PYG{+w}{        }\PYG{p}{(}\PYG{p}{(}\PYG{n}{sorter}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}
\PYG{+w}{            }\PYG{c+c1}{;; create new bst with same root node, same right\PYGZhy{}hand side, but a left\PYGZhy{}hand side that has had the item inserted}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nb}{list}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}item\PYGZus{}custom}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cadr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{sorter}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{caddr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{))}
\PYG{+w}{        }\PYG{p}{)}

\PYG{+w}{        }\PYG{c+c1}{;; if the item goes after the current node, insert it into the right\PYGZhy{}hand side of the tree}
\PYG{+w}{        }\PYG{p}{(}\PYG{p}{(}\PYG{n}{sorter}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{item}\PYG{p}{)}
\PYG{+w}{            }\PYG{c+c1}{;; create new bst with same root node, same left\PYGZhy{}hand side, but a right\PYGZhy{}hand side that has had the item inserted}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nb}{list}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cadr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}item\PYGZus{}custom}\PYG{+w}{ }\PYG{n}{item}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{caddr}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{sorter}\PYG{p}{))}
\PYG{+w}{        }\PYG{p}{)}

\PYG{+w}{        }\PYG{c+c1}{;; else the item is equal to the current node, so do nothing}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{else}\PYG{+w}{ }\PYG{n}{bst}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{)}
\PYG{p}{)}

\PYG{c+c1}{;; sorter function which states whether the two arguments were supplied in strictly ascending order (i.e., if item == item2, return false)}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sort\PYGZus{}ascending}\PYG{+w}{ }\PYG{n}{item1}\PYG{+w}{ }\PYG{n}{item2}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{item1}\PYG{+w}{ }\PYG{n}{item2}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+no}{\PYGZsh{}t}
\PYG{+w}{        }\PYG{n+no}{\PYGZsh{}f}
\PYG{+w}{    }\PYG{p}{)}
\PYG{p}{)}


\PYG{c+c1}{;; sorter function which states whether the two arguments were supplied in strictly descending order (i.e., if item == item2, return false)}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sort\PYGZus{}descending}\PYG{+w}{ }\PYG{n}{item1}\PYG{+w}{ }\PYG{n}{item2}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{item1}\PYG{+w}{ }\PYG{n}{item2}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+no}{\PYGZsh{}t}
\PYG{+w}{        }\PYG{n+no}{\PYGZsh{}f}
\PYG{+w}{    }\PYG{p}{)}
\PYG{p}{)}

\PYG{c+c1}{;; sorter function which states whether the two arguments were supplied in strictly ascending order based on the final digit (i.e., if item == item2, return false)}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sort\PYGZus{}ascending\PYGZus{}last}\PYG{+w}{ }\PYG{n}{item1}\PYG{+w}{ }\PYG{n}{item2}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{modulo}\PYG{+w}{ }\PYG{n}{item1}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{modulo}\PYG{+w}{ }\PYG{n}{item2}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{))}
\PYG{+w}{        }\PYG{n+no}{\PYGZsh{}t}
\PYG{+w}{        }\PYG{n+no}{\PYGZsh{}f}
\PYG{+w}{    }\PYG{p}{)}
\PYG{p}{)}

\PYG{c+c1}{;; function to insert a list of items into a binary search tree in the order determined by a sorting function}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}list\PYGZus{}custom}\PYG{+w}{ }\PYG{n}{lst}\PYG{+w}{ }\PYG{n}{bst}\PYG{+w}{ }\PYG{n}{sorter}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n}{lst}\PYG{p}{)}
\PYG{+w}{        }\PYG{c+c1}{;; if the list is null, just return the bst with no changes}
\PYG{+w}{        }\PYG{n}{bst}

\PYG{+w}{        }\PYG{c+c1}{;; otherwise, recurse with the remainder of the list and the binary tree produced by inserting the first item of the list into bst}
\PYG{+w}{        }\PYG{p}{(}\PYG{n}{insert\PYGZus{}list\PYGZus{}custom}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cdr}\PYG{+w}{ }\PYG{n}{lst}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{insert\PYGZus{}item\PYGZus{}custom}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{car}\PYG{+w}{ }\PYG{n}{lst}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{bst}\PYG{+w}{ }\PYG{n}{sorter}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{sorter}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{)}
\end{Verbatim}
